
import { spawn } from "child_process";
import fse from "fs-extra";
import * as readline from "readline";
import { VError } from "verror";

import * as pathutils from "path";
import { ILogger } from "./comm/ilogger";

export class PluginManager {

    /**
     * Actual constructor of the plugin manager. Asynchrounous because we might need it some initial setup later.
     * @param logger the logger to be used by the plugin manager
     * @param path the path where to add the plugins
     */
    public static async setup(logger: ILogger, path: string): Promise<PluginManager> {

        if (path == null) {
            throw new VError("path can't be null");
        }
        if (logger == null) {
            throw new VError("logger can't be null");
        }

        return new PluginManager(logger, path);
    }

    private logger: ILogger;
    private path: string;

    private constructor(logger: ILogger, path: string) {

        this.logger = logger;
        this.path = path;
    }

    /**
     * Install the libraries in the parameter. They can be required afterwards.
     * This currently uses npm underneath, so any errors npm would have, this will also have them.
     * Currently no support for native libraries.
     * @param dependencies the list of dependencies to install
     * @param peerDependencies the list of peer dependencies to install
     */
    public async install(
        dependencies: {[propName: string]: string},
        peerDependencies: {[propName: string]: string}): Promise<boolean> {
        if (dependencies == null) {
            throw new VError("dependencies parameter can't be null");
        }

        if (peerDependencies == null) {
            throw new VError("peerDependencies parameter can't be null");
        }

        const packageJsonPath = pathutils.join(this.path, "package.json");

        const packageJson = {
            name: "assetchef_autogenerated",
            version: "0.0.0",
            description: "auto generated",
            license: "MIT",
            repository: {},
            dependencies,
            peerDependencies,
        };

        const packageJsonJson: string = JSON.stringify(packageJson);

        try {
            await fse.writeFile(packageJsonPath, packageJsonJson);
        } catch (e) {
            this.logger.logError("Failed to write plugins config file due to: %s", e);
            return false;
        }

        let stdoutLineInterface: readline.Interface = null;
        let stderrLineInterface: readline.Interface = null;

        try {
            await new Promise((resolve, reject) => {
                const npm = spawn(
                    "npm",
                    ["install", "--production", "--loglevel=info", "--progress=false"],
                    {cwd: this.path, shell: true});

                stdoutLineInterface = readline.createInterface(npm.stdout).on("line", (data) => {
                    this.logger.logInfo(data);
                });

                stderrLineInterface = readline.createInterface(npm.stderr).on("line", (data) => {
                    this.logger.logInfo(data);
                });

                npm.on("close", (code) => {
                    stdoutLineInterface.close();
                    stderrLineInterface.close();
                    if (code !== 0) {
                        reject("npm exited with error code" + code);
                    } else {
                        resolve();
                    }
                });
            });

        } catch (e) {
            this.logger.logError("Npm failed to install plugins due to: %s", e);
            return false;
        } finally /* istanbul ignore next */ {
            if (stderrLineInterface != null) {
                stderrLineInterface.close();
            }
            if (stdoutLineInterface != null) {
                stdoutLineInterface.close();
            }
        }

        return true;
    }

    /**
     * Require a plugin. This will return null if it's not found, and log the error.
     * The require through here is always uncached.
     * @param name the name of the plugin
     */
    public require<T>(name: string): T {
        if (name == null) {
            throw new VError("name parameter can't be null");
        }

        const prevPaths = module.paths;
        module.paths.push(pathutils.join(this.path, "node_modules"));

        try {
            delete require.cache[require.resolve(name)];
            return require(name);
        } catch (e) {
            this.logger.logError("Failed to require %s with error: %s", name, e);
            return null;
        } finally {
            module.paths = prevPaths;
        }
    }
}
