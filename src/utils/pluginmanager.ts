import { ILogger, LoggerLevel } from "../plugin/ilogger";

import fse from "fs-extra";
import npm from "npm";
import * as pathutils from "path";
import VError from "verror";
import { ConsoleToLogger } from "./consoletologger";

export class PluginManager {

    /**
     * Actual constructor of the plugin manager. Asynchrounous because we might need it some initial setup later.
     * @param logger the logger to be used by the plugin manager
     * @param path the path where to add the plugins
     */
    public static async setup(logger: ILogger, path: string): Promise<PluginManager> {

        if (path == null) {
            throw new VError("path can't be null");
        }
        if (logger == null) {
            throw new VError("logger can't be null");
        }

        return new PluginManager(logger, path);
    }

    private logger: ILogger;
    private path: string;

    private constructor(logger: ILogger, path: string) {

        this.logger = logger;
        this.path = path;
    }

    /**
     * Install the libraries in the parameter. They can be required afterwards.
     * This currently uses npm underneath, so any errors npm would have, this will also have them.
     * Currently no support for native libraries.
     * @param libraries the list of libraries to install
     */
    public async install(dependencies: {[propName: string]: string}): Promise<boolean> {
        if (dependencies == null) {
            throw new VError("dependencies parameter can't be null");
        }

        const packageJsonPath = pathutils.join(this.path, "package.json");

        const packageJson = {
            name: "assetchef_autogenerated",
            version: "0.0.0",
            description: "auto generated",
            license: "MIT",
            repository: {},
            dependencies,
        };

        const packageJsonJson: string = JSON.stringify(packageJson);

        try {
            await fse.writeFile(packageJsonPath, packageJsonJson);
        } catch (e) {
            this.logger.logError("Failed to write plugins config file due to: %s", e);
            return false;
        }

        const consoleToLoggerCanceller = ConsoleToLogger.redirect(this.logger, LoggerLevel.info, LoggerLevel.info);

        try {
            await new Promise((resolve, reject) => {
                npm.load({_exit: false, loglevel: "info", parseable: true}, (e: any) => {
                    /* istanbul ignore next */
                    if (e == null) {
                        resolve();
                    } else {
                        /* istanbul ignore next */
                        reject(e);
                    }
                });
            });

            await new Promise((resolve, reject) => {
                (npm.commands.install as any)(this.path, [], (e: any) => {
                    if (e == null) {
                        resolve();
                    } else {
                        reject(e);
                    }
                });
            });
        } catch (e) {
            consoleToLoggerCanceller.cancel();
            this.logger.logError("Npm failed to install plugins due to: %s", e);
            return false;
        }  finally {
            consoleToLoggerCanceller.cancel();
        }

        return true;
    }

    /**
     * Require a plugin. This will return null if it's not found, and log the error.
     * The require through here is always uncached.
     * @param name the name of the plugin
     */
    public require<T>(name: string): T {
        if (name == null) {
            throw new VError("name parameter can't be null");
        }

        const prevPaths = module.paths;
        module.paths = [pathutils.join(this.path, "node_modules")];

        try {
            delete require.cache[require.resolve(name)];
            return require(name);
        } catch (e) {
            this.logger.logError("Failed to require %s with error: %s", name, e);
            return null;
        } finally {
            module.paths = prevPaths;
        }
    }
}
