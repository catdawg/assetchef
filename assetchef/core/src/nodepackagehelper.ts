
import { spawn } from "child_process";
import fse from "fs-extra";
import * as readline from "readline";
import { VError } from "verror";

import * as pathutils from "path";
import { ILogger } from "./comm/ilogger";

export class NodePackageHelper {
    /**
     * Install the libraries in the parameter into the path specified.
     * This currently uses npm underneath, so any errors npm would have, this will also have them.
     * Be advised that if the folder already contains a package.json or a node_modules folder, these will be overriten
     * Currently no support for native libraries.
     * @param path the path to install the libraries
     * @param dependencies the list of dependencies to install
     */
    public static async install(
        logger: ILogger,
        path: string,
        dependencies: {[propName: string]: string}): Promise<boolean> {
        if (logger == null) {
            throw new VError("logger parameter can't be null");
        }

        if (path == null) {
            throw new VError("path parameter can't be null");
        }

        if (dependencies == null) {
            throw new VError("dependencies parameter can't be null");
        }

        try {
            const stat = await fse.stat(path);

            if (!stat.isDirectory()) {
                logger.logError("tried to npm install into path '%s' that is not a directory", path);
                return false;
            }
        } catch (e) {
            logger.logError("can't npm install into '%s', error: %s", path, e.message);
            return false;
        }

        const packageJsonPath = pathutils.join(path, "package.json");

        const packageJson = {
            name: "assetchef_autogenerated",
            version: "0.0.0",
            description: "auto generated",
            license: "MIT",
            repository: {},
            dependencies,
        };

        const packageJsonJson: string = JSON.stringify(packageJson);

        try {
            await fse.writeFile(packageJsonPath, packageJsonJson);
        } catch (e) /* istanbul ignore next */ {
            logger.logError("Failed to write package.json for npm install in path '%s' due to: %s", e);
            return false;
        }

        let stdoutLineInterface: readline.Interface = null;
        let stderrLineInterface: readline.Interface = null;

        try {
            await new Promise((resolve, reject) => {
                const npm = spawn(
                    "npm",
                    ["install", "--production", "--loglevel=info", "--progress=false"],
                    {cwd: path, shell: true});

                stdoutLineInterface = readline.createInterface(npm.stdout).on("line", (data) => {
                    logger.logInfo(data);
                });

                stderrLineInterface = readline.createInterface(npm.stderr).on("line", (data) => {
                    logger.logInfo(data);
                });

                npm.on("close", (code) => {
                    stdoutLineInterface.close();
                    stderrLineInterface.close();
                    if (code !== 0) {
                        reject("npm exited with error code" + code);
                    } else {
                        resolve();
                    }
                });
            });

        } catch (e) {
            logger.logError("Npm failed to install plugins due to: %s", e);
            return false;
        } finally /* istanbul ignore next */ {
            if (stderrLineInterface != null) {
                stderrLineInterface.close();
            }
            if (stdoutLineInterface != null) {
                stdoutLineInterface.close();
            }
        }

        return true;
    }

    /**
     * Require a plugin. This will return work like the normal require, except that it looks on a specific path only.
     * @param name the name of the plugin
     * @throws whatever require can throw. e.g. if not found.
     */
    public static requireFromPath<T>(path: string, name: string): T {
        if (path == null) {
            throw new VError("path parameter can't be null");
        }
        if (name == null) {
            throw new VError("name parameter can't be null");
        }
        const requireResolveOptions = {paths: [pathutils.join(path, "node_modules")]};

        const resolveRes = require.resolve(name, requireResolveOptions);
        return require(resolveRes);
    }
}
